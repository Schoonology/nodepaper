#!/usr/bin/env node
var fs = require('fs')
  , http = require('http')
  , path = require('path')
  , async = require('async')
  , express = require('express')
  , LRU = require('lru-cache')
  , marked = require('marked')
  , sorted = require('sorted')
  , watch = require('watch')
  , MAX_PREAMBLE_LENGTH = 1028
  , PREAMBLE_REGEX = /([a-z]+)\s*:(.*)/i
  , THEME_BREAK = '{break}'
  , cache = LRU({
      max: 100,
      maxAge: 1000 * 60 * 60,
      length: function (value) { return value.length },
      dispose: function (key, value) {},
      stale: true
    })
  , app = express()
  , postsdir = path.resolve(process.cwd(), process.argv[2])
  , themefile = path.resolve(process.cwd(), process.argv[3])
  , postIndex = sorted(function (a, b) {
      return b.date - a.date
    })
  , theme = []
  , monitor

marked.setOptions({
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: true,
  smartLists: true
})

//
// ## getName `getName(file)`
//
// Returns either the basename-extname of **file** or null.
//
function getName(file) {
  var name = path.relative(postsdir, file)
    , extname = path.extname(name)

  if (['.md'].indexOf(extname) < 0) {
    return null
  }

  return path.basename(name, extname)
}

//
// ## updateIndex `updateIndex(file)`
//
// Updates the sorted post index with the metadata from **file**.
//
function updateIndex(file) {
  var name = getName(file)

  if (!name) {
    return
  }

  preamble(name, function (err, meta) {
    if (err) {
      console.error(err)
      return
    }

    // Pre-processing
    meta.name = name
    meta.date = Date.parse(meta.date)

    if (postIndex[name]) {
      postIndex.splice(postIndex[name].index, 1)
    }

    meta.index = postIndex.findIndex(meta)
    postIndex.push(meta)
    postIndex[name] = meta
  })
}

//
// ## removeFromIndex `removeFromIndex(file)`
//
// Removes the index for **file**.
//
function removeFromIndex(file) {
  var name = getName(file)
    , existing

  if (!name) {
    return
  }

  if (!postIndex[name]) {
    return
  }

  postIndex.splice(postIndex[name].index, 1)
  ;delete postIndex[name]
}

//
// ## parsePreamble `parsePreamble(file)`
//
// Parses the parsePreamble from **file**, returning a tuple of { meta: rest }.
//
function parsePreamble(file) {
  var data = {}
    , active = true
    , match
    , key
    , value

  file = file.split('\n').filter(function (line) {
    if (!active) {
      return true
    }

    line = line.trim()

    if (line.length === 0) {
      return false
    }

    match = PREAMBLE_REGEX.exec(line)

    if (!match) {
      active = false
      return true
    }

    key = match[1].toLowerCase()
    value = match[2].trim()

    data[key] = value
    return false
  }).join('\n')

  return {
    meta: data,
    rest: file
  }
}

//
// ## contents `contents(name, callback)`
//
// Loads the entire contents of the **name** file, passing the result as a { meta, md } tuple to **callback**.
//
function contents(name, callback) {
  var cached = cache.get(name)

  if (cached) {
    callback(null, cached)
    return
  }

  fs.readFile(path.join(postsdir, name + '.md'), 'utf8', function (err, file) {
    if (err) {
      callback(err)
      return
    }

    var data = parsePreamble(file)

    data = {
      meta: data.meta,
      html: marked(data.rest)
    }

    cache.set(name, data)
    callback(null, data)
  })
}

//
// ## preamble `preamble(name, callback)`
//
// Loads and parses the **name** file, passing an Object with the parsed values to **callback**.
//
function preamble(name, callback) {
  contents(name, function (err, tuple) {
    if (err) {
      callback(err)
      return
    }

    callback(null, tuple.meta)
  })
}

//
// ## markdown `markdown(name, callback)
//
// Loads and parses the Markdown contents of the **name** file, passing the compiled HTML to **callback**.
//
function markdown(name, callback) {
  contents(name, function (err, tuple) {
    if (err) {
      callback(err)
      return
    }

    callback(null, tuple.html)
  })
}

//
// ## loadTheme `loadTheme(file, callback)`
//
// Loads the theme **file**, passing nothing to **callback**.
//
function loadTheme(file, callback) {
  fs.readFile(file, function (err, buffer) {
    if (err) {
      callback(err)
      return
    }

    file = String(buffer)
    theme = file.split(THEME_BREAK)

    if (theme.length < 2 || theme.length > 3) {
      console.error('Invalid theme:', theme)
      theme = []
    }

    callback()
  })
}

//
// ## wrapped `wrapped(html, callback)`
//
// Loads the configured theme and wraps **html** in it, passing the result to **callback**.
//
function wrapped(html, callback) {
  var header = ''
    , middle = '\n'
    , footer = ''

  if (theme.length === 2) {
    header = theme[0]
    footer = theme[1]
  } else if (theme.length === 3) {
    header = theme[0]
    middle = theme[1]
    footer = theme[2]
  }

  if (Array.isArray(html)) {
    html = html.join(middle)
  }

  callback(null, header + html + footer)
}

app.get('/', function (req, res, next) {
  async
    .map(
      postIndex.slice(0, 3).toArray(),
      function (meta, callback) {
        markdown(meta.name, callback)
      },
      function (err, htmls) {
        if (err) {
          next(err)
          return
        }

        wrapped(htmls, function (err, html) {
          if (err) {
            next(err)
            return
          }

          res.send(html)
        })
      }
    )
})

app.get('/:name', function (req, res, next) {
  var name = req.params.name

  markdown(name, function (err, html) {
    if (err) {
      next(err)
      return
    }

    wrapped(html, function (err, html) {
      if (err) {
        next(err)
        return
      }

      res.send(html)
    })
  })
})

watch.watchTree(postsdir, function (f, curr, prev) {
  if (typeof f === 'object' && prev === null && curr === null) {
    Object.keys(f).forEach(updateIndex)
  } else if (curr.nlink === 0) {
    removeFromIndex(f)
  } else {
    updateIndex(f)
  }
})

loadTheme(themefile, function (err) {
  if (err) {
    console.error(err)
    process.exit(2)
  }

  http.createServer(app).listen(8080, function (err) {
    if (err) {
      console.error(err)
      process.exit(1)
    }

    console.log('Listening on port 8080...')
  })
})
